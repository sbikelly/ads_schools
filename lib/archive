import 'package:ads_schools/models/models.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';

class FirebaseService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  
  /// Calculates positions efficiently using Firestore queries
  static Future<void> calculatePositions({required classId, required sessionId,required termId, required subjectId}) async {
    final scoresRef = FirebaseFirestore.instance
        .collection('classes')
        .doc(classId)
        .collection('sessions')
        .doc(sessionId)
        .collection('terms')
        .doc(termId)
        .collection('subjects').doc(subjectId).collection('scores');

    final scoresQuery = await scoresRef.orderBy('total', descending: true).get();

    final batch = FirebaseFirestore.instance.batch();
    int position = 1;

    for (var doc in scoresQuery.docs) {
      batch.update(doc.reference, {'position': position.toString()});
      position++;
    }

    await batch.commit();
  }

  /// Helper function to get grade and remark
  static Map<String, String> getGradeAndRemark(int total) {
    if (total >= 85) return {'grade': 'A', 'remark': 'Excellent'};
    if (total >= 80) return {'grade': 'B2', 'remark': 'Very Good'};
    if (total >= 75) return {'grade': 'B3', 'remark': 'Good'};
    if (total >= 70) return {'grade': 'C4', 'remark': 'Fair'};
    if (total >= 65) return {'grade': 'C5', 'remark': 'Satisfactory'};
    if (total >= 50) return {'grade': 'D7', 'remark': 'Pass'};
    return {'grade': 'F9', 'remark': 'Fail'};
  }

  /// Deletes documents in batches with pagination
  Future<void> deleteDocumentsWhere(String collectionPath, String field, dynamic value) async {
    final query = _firestore.collection(collectionPath).where(field, isEqualTo: value).limit(500);

    while (true) {
      final snapshot = await query.get();

      if (snapshot.docs.isEmpty) break;

      final batch = _firestore.batch();
      for (var doc in snapshot.docs) {
        batch.delete(doc.reference);
      }
      await batch.commit();
    }
  }

  /// Batches writes for large operations
  Future<void> batchUpdateScores(List<SubjectScore> scores, String classId, String sessionId, String termId) async {
    const batchSize = 500;
    final scoresRef = _firestore
        .collection('classes')
        .doc(classId)
        .collection('sessions')
        .doc(sessionId)
        .collection('terms')
        .doc(termId)
        .collection('scores');

    for (var i = 0; i < scores.length; i += batchSize) {
      final batch = _firestore.batch();
      final chunk = scores.sublist(i, i + batchSize);

      for (var score in chunk) {
        final docRef = scoresRef.doc(score.regNo);
        batch.set(docRef, score.toMap(), SetOptions(merge: true));
      }

      await batch.commit();
    }
  }

  /// Fetches a document by ID
  static Future<Map<String, dynamic>?> getDocumentById(String collectionPath, String docId) async {
    try {
      final docSnapshot = await FirebaseFirestore.instance.collection(collectionPath).doc(docId).get();
      return docSnapshot.exists ? docSnapshot.data() : null;
    } catch (e) {
      debugPrint('Error fetching document: $e');
      return null;
    }
  }

  /// Fetches documents based on a condition
  static Future<QuerySnapshot<Map<String, dynamic>>> getWhere({required collection, required fields, required value}) async {
    try {
      final querySnapshot = await FirebaseFirestore.instance.collection(collection).where(fields, isEqualTo: value).get();
      return querySnapshot;
    } catch (e) {
      debugPrint('Error fetching documents: $e');
       // Return an empty snapshot in case of an error
    return QuerySnapshot<Map<String, dynamic>>(
      FirebaseFirestore.instance, 
      FirebaseFirestore.instance.collection(collection),
      [], // Empty list of documents
      null, // Document snapshots are null in case of error
    );
    }
  }
  static Future<String> createClass(String name) async {
    final classRef = FirebaseFirestore.instance.collection('classes').doc();

    final schoolClass = SchoolClass(
      id: classRef.id,
      name: name,
      createdAt: DateTime.now(),
    );

    await classRef.set(schoolClass.toMap());
    return classRef.id;
  }

  static Future <void> saveStudentScores({
    required String classId,
    required String sessionId,
    required String termId,
    required String subjectId,
    required List<SubjectScore> scores,
  }) async {
    try {
      final batch = FirebaseFirestore.instance.batch();
      final scoresRef = FirebaseFirestore.instance
          .collection('classes')
          .doc(classId)
          .collection('sessions')
          .doc(sessionId)
          .collection('terms')
          .doc(termId)
          .collection('subjects')
          .doc(subjectId)
          .collection('scores');

      // Add all scores in batch
      for (final score in scores) {
        if (score.regNo.isNotEmpty) {
          final docRef = scoresRef.doc(score.regNo);
          batch.set(docRef, score.toMap(), SetOptions(merge: true));
        }
      }

      await batch.commit();
      debugPrint('Successfully saved ${scores.length} scores');
    } catch (e) {
      debugPrint('Error saving scores: $e');
      throw Exception('Failed to save scores: $e');
    }
  }

 static Future<void> setupClassStructure({
    required String classId,
    required List<String> sessions,
    required Map<String, List<String>> termsAndSubjects,
  }) async {
    final classRef =
        FirebaseFirestore.instance.collection('classes').doc(classId);
    debugPrint('Setting up class structure for class ID: $classId');
    for (final session in sessions) {
      final sessionRef = classRef.collection('sessions').doc();
      debugPrint('Setting up session: $session');

      await sessionRef.set(Session(id: sessionRef.id, name: session).toMap());
      debugPrint('Session setup completed');

      for (final term in termsAndSubjects.keys) {
        final termRef = sessionRef.collection('terms').doc();
        debugPrint('Setting up term: $term');
        await termRef.set(Term(id: termRef.id, name: term).toMap());
        debugPrint('Term setup completed');
        for (final subject in termsAndSubjects[term]!) {
          final subjectRef = termRef.collection('subjects').doc();
          debugPrint('Setting up subject: $subject');
          await subjectRef.set(Subject(name: subject).toMap());
          debugPrint('Subject setup completed');
        }
      }
    }
  }

 static Future<void> updateClass(
    String classId,
    String newName, {
    required List<String> sessions,
    required Map<String, List<String>> termsAndSubjects,
  }) async {
    try {
      // Update class name
      final classRef =
          FirebaseFirestore.instance.collection('classes').doc(classId);
      await classRef.update({'name': newName});

      // Delete existing structure
      final sessionQuery = await classRef.collection('sessions').get();
      for (var session in sessionQuery.docs) {
        await session.reference.delete();
      }

      // Setup new structure
      await setupClassStructure(
        classId: classId,
        sessions: sessions,
        termsAndSubjects: termsAndSubjects,
      );

      debugPrint('Class updated successfully');
    } catch (e) {
      debugPrint('Error updating class: $e');
      throw Exception('Failed to update class: $e');
    }
  }

 static Future<void> uploadBatchSubjectScores({
    required String classId,
    required String sessionId,
    required String termId,
    required String subjectId,
    required List<SubjectScore> scores,
  }) async {
    try {
      final batch = FirebaseFirestore.instance.batch();
      final scoresRef = FirebaseFirestore.instance
          .collection('classes')
          .doc(classId)
          .collection('sessions')
          .doc(sessionId)
          .collection('terms')
          .doc(termId)
          .collection('subjects')
          .doc(subjectId)
          .collection('scores');

      for (var score in scores) {
        if (score.regNo.isNotEmpty) {
          final docRef = scoresRef.doc(score.regNo);
          final total = (score.ca1 ?? 0) + (score.ca2 ?? 0) + (score.exam ?? 0);

          final scoreMap = score.toMap();
          scoreMap['total'] = total;
          3;
          // Calling the function
  Map<String, String> result = getGradeAndRemark(total);
  
  // Accessing the grade and remark
  String grade = result['grade']!;
  String remark = result['remark']!;

          scoreMap['grade'] = grade;
          scoreMap['remark'] = remark;
          final classAverage =
              total / 3; // Calculate subject average (CA1 + CA2 + Exam) / 3
          // Save class average
          scoreMap['average'] = double.parse(classAverage.toStringAsFixed(2));

          batch.set(docRef, scoreMap, SetOptions(merge: true));
        }
      }

      await batch.commit();
      debugPrint('Successfully uploaded ${scores.length} scores');

      // Calculate positions after scores are uploaded
      await calculatePositions(
        classId: classId,
        sessionId: sessionId,
        termId: termId,
        subjectId: subjectId,
      );
    } catch (e) {
      debugPrint('Error uploading batch scores: $e');
      throw Exception('Failed to upload batch scores: $e');
    }
  }

  static Future<DocumentReference?> addDocument<T>({
    required String collection,
    required T document,
    required Map<String, dynamic> Function(T) toJsonOrMap,
  }) async {
    try {
      final docRef = await FirebaseFirestore.instance
          .collection(collection)
          .add(toJsonOrMap(document));
      debugPrint('Document added to $collection');
      return docRef;
    } catch (e) {
      throw Exception('Error adding document: $e');
    }
  }

  static Future<void> deleteDocument(
      String collection, String documentId) async {
    try {
      await FirebaseFirestore.instance
          .collection(collection)
          .doc(documentId)
          .delete();
    } catch (e) {
      throw Exception('Failed to delete document: $e');
    }
  }

  static Future<List<SubjectScore>> fetchStudentScores({
    required String classId,
    required String sessionId,
    required String termId,
    required String regNo,
  }) async {
    final List<SubjectScore> studentScores = [];
    try {
      final subjectsRef = FirebaseFirestore.instance
          .collection('classes')
          .doc(classId)
          .collection('sessions')
          .doc(sessionId)
          .collection('terms')
          .doc(termId)
          .collection('subjects');
      // Fetch all subjects in the term
      final subjectsSnapshot = await subjectsRef.get();

      for (var subjectDoc in subjectsSnapshot.docs) {
        // Convert subject document to Subject model
        final subjectData = subjectDoc.data();
        final subject = Subject.fromFirestore(subjectData);
        final scoresRef = subjectsRef
            .doc(subjectDoc.id)
            .collection('scores')
            .where('regNo', isEqualTo: regNo);
        // Fetch the student's score for this subject
        final scoresSnapshot = await scoresRef.get();

        for (var scoreDoc in scoresSnapshot.docs) {
          final data = scoreDoc.data();
          debugPrint('converting fetched scores into SubjectScore Model');
          // Convert Firestore document to SubjectScore
          final score = SubjectScore(
            regNo: data['regNo'],
            subjectName: subject.name, // Use subject name from Subject model
            ca1: data['ca1'] ?? 0,
            ca2: data['ca2'] ?? 0,
            exam: data['exam'] ?? 0,
            total: data['total'] ?? 0,
            average: data['average'] ?? 0.0,
            position: data['position'] ?? '',
            grade: data['grade'] ?? '',
            remark: data['remark'] ?? '',
          );
          debugPrint('Subject scores converted!');
          studentScores.add(score);
        }
      }
      return studentScores;
    } catch (e) {
      debugPrint('Error fetching scores: $e');
      throw Exception('Failed to fetch scores: $e');
    }
  }

  static Future<List<Map<String, dynamic>>> fetchStudentScores1({
    required String classId,
    required String sessionId,
    required String termId,
    required String regNo,
  }) async {
    final subjectsRef = FirebaseFirestore.instance
        .collection('classes')
        .doc(classId)
        .collection('sessions')
        .doc(sessionId)
        .collection('terms')
        .doc(termId)
        .collection('subjects');

    try {
      // Fetch all subjects
      final subjectsSnapshot = await subjectsRef.get();

      if (subjectsSnapshot.docs.isEmpty) return [];

      // Initialize a list to hold the student's scores for each subject
      List<Map<String, dynamic>> studentScores = [];

      // Loop through each subject and fetch the student's score
      for (var subjectDoc in subjectsSnapshot.docs) {
        final subjectId = subjectDoc.id;

        final scoreDoc = await subjectsRef
            .doc(subjectId)
            .collection('scores')
            .doc(regNo)
            .get();

        if (scoreDoc.exists) {
          final scoreData = scoreDoc.data();
          studentScores.add({
            'subjectId': subjectId,
            ...?scoreData,
          });
        }
      }

      return studentScores;
    } catch (e) {
      debugPrint('Error fetching student scores: $e');
      throw Exception('Failed to fetch student scores: $e');
    }
  }

  static Future<List<DocumentSnapshot>> getAllDocuments(
      String collection) async {
    try {
      final querySnapshot =
          await FirebaseFirestore.instance.collection(collection).get();
      return querySnapshot.docs;
    } catch (e) {
      throw Exception('Failed to fetch documents: $e');
    }
  }

  static Stream<List<T>> getDataStream<T>({
    required String collection,
    required T Function(Map<String, dynamic>) fromMap,
    Map<String, dynamic>? queryFields,
  }) {
    try {
      Query query = FirebaseFirestore.instance.collection(collection);
      if (queryFields != null) {
        queryFields.forEach((key, value) {
          query = query.where(key, isEqualTo: value);
        });
      }

      return query.snapshots().map((snapshot) => snapshot.docs
          .map((doc) => fromMap(doc.data() as Map<String, dynamic>))
          .toList());
    } catch (e) {
      throw Exception('Failed to get data stream: $e');
    }
  }

  
  static Future<Map<String, dynamic>> getReportCardData(
      {classId, sessionId, termId, studentId}) async {
    try {
      debugPrint('Fetching report card data for student ID: $studentId');

      // Get student info
      debugPrint('Fetching student information...');
      final studentDoc = await getDocumentById('students', studentId!);
      final student = Student.toMap(studentDoc);
      debugPrint('Student info retrieved: ${student.toString()}');

      // Get subject scores
      final subjectScores = await fetchStudentScores(
        classId: classId,
        sessionId: sessionId,
        termId: termId,
        regNo: 'STD001',
      );
      debugPrint('Subjects fetched');

      for (var score in subjectScores) {
        debugPrint(
            'Subject: ${score.subjectName}, Total: ${score.total}, Position: ${score.position}, Grade: ${score.grade}');
      }

      // Get domain scores (skills and traits)
      debugPrint('Fetching domain scores...');
      final domainQuery = await getWhere(
        collection: 'assessment',
        fields: 'regNo',
        value: 'STD001',
      );
      final domainScores = domainQuery.docs
          .map((doc) => Assessment.fromMap(doc.data() as Map<String, dynamic>))
          .toList();
      debugPrint('Retrieved ${domainScores.length} domain scores');

      final result = {
        'student': student,
        'subjectScores': subjectScores,
        'domainScores': domainScores,
      };
      debugPrint('Successfully compiled report card data');
      return result;
    } catch (e) {
      debugPrint('Error fetching report card data: $e');
      throw Exception('Failed to fetch report card data: $e');
    }
  }

  
  static Future<DocumentReference> updateOrAddDocument<T>({
    required String collection,
    required T document,
    required Map<String, dynamic> queryFields,
    required Map<String, dynamic> Function(T) toJsonOrMap,
  }) async {
    try {
      final collectionRef = FirebaseFirestore.instance.collection(collection);
      final query = queryFields.entries.fold(
        collectionRef as Query,
        (query, field) => query.where(field.key, isEqualTo: field.value),
      );

      final querySnapshot = await query.limit(1).get();
      final documentData = toJsonOrMap(document);

      if (querySnapshot.docs.isNotEmpty) {
        final docRef = querySnapshot.docs.first.reference;
        await docRef.update(documentData);
        debugPrint('Document updated in $collection');
        return docRef;
      }

      final newDocRef = await collectionRef.add(documentData);
      debugPrint('New document added to $collection');
      return newDocRef;
    } catch (e) {
      throw Exception('Error updating or adding document: $e');
    }
  }
}
